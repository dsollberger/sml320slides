---
title: "18: Non-Normal Hierarchical Models"
author: "Derek Sollberger"
date: "2024-04-11"
execute:
  cache: true
# format:
#   revealjs:
#     scrollable: true
format:
  html:
    toc: true
---

\newcommand{\ds}{\displaystyle}

# Non-Normal Hierarchical Models
:::: {.columns}

::: {.column width="45%"}
**Goals:** 

* Further explore hierarchical models
* Apply the Bayesian mindset to neural networks

:::

::: {.column width="10%"}

:::

::: {.column width="45%"}
```{r}
#| message: false
#| warning: false

library("bayesplot")
library("bayesrules")
library("BLNN")
library("ggtext")
library("janitor")
library("nnet")
library("patchwork")
library("rstan")
library("rstanarm")
library("tidyverse")

knitr::opts_chunk$set(echo = TRUE)

airbnb_raw <- readr::read_csv("listings.csv")

# brand colors
# https://pickcoloronline.com/brands/airbnb/
airbnb_red <- "#FF5A5F"
airbnb_green <- "#00A699"
airbnb_orange <- "#FC642D"
airbnb_black <- "#484848"
airbnb_gray <- "#767676"
```
:::

::::

## Data

:::: {.columns}

::: {.column width="45%"}
* source: [Airbnb](https://insideairbnb.com/get-the-data/) listings
* 22 December, 2023
* "Summary information and metrics for listings in Jersey City (good for visualisations)."

Before data wrangling:

* 1549 observations
* 18 variables



:::

::: {.column width="10%"}

:::

::: {.column width="45%"}
![Jersey City, NJ](jersey_city_broad.png)
:::

::::


## Data Wrangling

:::: {.columns}

::: {.column width="45%"}

* extracted `ward` classification
* nonzero `availablity_365`
* excluded rare "Hotel" or "Shared Room" listing
* removed observations with missing values

After data wrangling:

* 1348 observations
* 7 variables	
:::

::: {.column width="10%"}

:::

::: {.column width="45%"}
```{r}
airbnb_df <- airbnb_raw |>
  mutate(ward = stringr::str_sub(neighbourhood,6,6)) |>
  select(price, host_id, number_of_reviews, availability_365, 
         room_type, ward) |>
  filter(availability_365 > 0) |>
  filter(room_type %in% c("Entire home/apt", "Private room")) |>
  na.omit() |>
  group_by(host_id) |>
  mutate(listings = n()) |>
  ungroup()
```

:::

::::

## Variables

:::: {.columns}

::: {.column width="45%"}
### Response Variable

$Y$: price of Airbnb listing

* numerical response

### Predictor Variables

* $X_{1}$: number of reviews
* $X_{2}$: availability over year (1 to 365 days)
* $X_{3}$: room type (entire place or private room)
:::

::: {.column width="10%"}

:::

::: {.column width="45%"}


### Tier Variables

* `ward`: political subdivision of Jersey City

![Jersey City, NJ](jersey_city_wards.png)

:::

::::


# Interaction Hierarchies

::::: {.panel-tabset}

## Stan

```{r}
#| echo: true
#| eval: false
ward_intercept_model <- rstanarm::stan_glmer(
  price ~ number_of_reviews + availability_365 + room_type + 
    (1 | ward), ...)

ward_interaction_model <- rstanarm::stan_glmer(
  price ~ number_of_reviews + availability_365 + room_type + 
    (room_type | ward), ...)
```

$$\mu_{ij} = \beta_{0j} + \beta_{1}X_{ij1} + \beta_{2}X_{ij2} + \beta_{3}X_{ij3}$$

* assumes relationships between price and predictors are similar for each `ward`

$$\mu_{ij} = \beta_{0j} + \beta_{1j}X_{ij1} + \beta_{2}X_{ij2} + \beta_{3}X_{ij3}$$

* assumes that the relationship between price and `room_type` might be different for each `ward`


## Code

```{r}
start_time <- Sys.time()

airbnb_for_stan <- airbnb_df |>
  mutate(room_bin = ifelse(room_type == "Entire home/apt", 1, 0)) |>
  group_by(ward) |>
  slice_sample(prop = 0.2) |>
  ungroup()

ward_intercept_model <- rstanarm::stan_glmer(
  price ~ number_of_reviews + availability_365 + room_type + 
    (1 | ward),
  data = airbnb_for_stan, family = gaussian,
  adapt_delta = 0.999, chains = 3, iter = 3000*2, refresh = 0, seed = 320)

ward_interaction_model <- rstanarm::stan_glmer(
  price ~ number_of_reviews + availability_365 + room_type + 
    (room_type | ward),
  data = airbnb_for_stan, family = gaussian,
  adapt_delta = 0.999, chains = 3, iter = 3000*2, refresh = 0, seed = 320)

end_time <- Sys.time()
print(round(end_time- start_time))
```

## Diagnostics

::: {.callout-note collapse="true"}
## Function

```{r}
model_diagnostics <- function(the_stan_model){
  p1 <- bayesplot::mcmc_trace(the_stan_model, size = 0.1) +
  labs(title = "MCMC Traces")
  print(p1)
  
  p2 <- bayesplot::mcmc_dens_overlay(the_stan_model) +
  labs(title = "Density Plots")
  print(p2)
  
  p3 <- bayesplot::mcmc_acf(the_stan_model) +
  labs(title = "Autocorrelations")
  print(p3)
  
  # effective sample size
  print("Effective Sample Size:")
  print(bayesplot::neff_ratio(the_stan_model))
  
  # split-R metric
  print("R-Hat")
  print(bayesplot::rhat(the_stan_model))
}
```

:::

```{r}
#| message: false
#| warning: false
model_diagnostics(ward_intercept_model)
```

```{r}
#| message: false
#| warning: false
model_diagnostics(ward_interaction_model)
```

## MAE

```{r}
set.seed(320)
bayesrules::prediction_summary(ward_intercept_model, data = airbnb_df) |>
  mutate_if(is.numeric, round, digits = 4)
```

```{r}
set.seed(320)
bayesrules::prediction_summary(ward_interaction_model, data = airbnb_df) |>
  mutate_if(is.numeric, round, digits = 4)
```

## PPC

```{r}
#| echo: false
#| eval: true
p1 <- bayesplot::pp_check(ward_intercept_model) +
  labs(title = "Ward Intercept Model", x = "price") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")
p2 <- bayesplot::pp_check(ward_interaction_model) +
  labs(title = "Ward Interaction Model", x = "price") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "bottom")

p1 + p2
```

```{r}
#| echo: true
#| eval: false
p1 <- bayesplot::pp_check(ward_intercept_model) +
  labs(title = "Ward Intercept Model", x = "price") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")
p2 <- bayesplot::pp_check(ward_interaction_model) +
  labs(title = "Ward Interaction Model", x = "price") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "bottom")

p1 + p2
```

:::::


# Model Statistics

## Coefficients

```{r}
broom.mixed::tidy(ward_intercept_model, 
                  effects = "fixed", #beta coefficients
                  conf.int = TRUE, conf.level = 0.90) |>
  mutate_if(is.numeric, round, digits = 4)
```

* $\beta_{0}$ (practically significant): when $X_{1} = X_{2} = 0$ and the Airbnb listing is for a whole house/apartment, the average price is about $186
* $\beta_{1}$ (practically significant): for each review of the location, the price decreases by about 15 cents.
* $\beta_{2}$ (practically significant): for every additional day that the location is available during the year, the price increases by about 13 cents.
* $\beta_{3}$ (practically significant): compared to the baseline of "Entire house/apt" locations, the private room listings tend to be about $115 cheaper.

## Hierarchy

```{r}
broom.mixed::tidy(ward_intercept_model, 
                  effects = "ran_vals", #values of randomness
                  conf.int = TRUE, conf.level = 0.90) |>
  mutate_if(is.numeric, round, digits = 4)
```

**Ward E** is the only one that is "practically significant" (based on the 90-percent credible intervals for the coefficients), and its coefficient shows how listings in that ward tend to be more expensive than the population average.


## ANOVA

```{r}
var_df <- broom.mixed::tidy(ward_intercept_model, 
                  effects = "ran_pars", #parameters of randomness
                  conf.int = TRUE, conf.level = 0.90) |>
  mutate_if(is.numeric, round, digits = 4)

var_df #print
```

::: {.callout-note collapse="true"}
## Function

```{r}
Extract_Variances <- function(V){
  v1 <- unlist(V[1,3]^2 / (V[1,3]^2 + V[2,3]^2)) |> round(digits = 4)
  v2 <- unlist(V[2,3]^2 / (V[1,3]^2 + V[2,3]^2)) |> round(digits = 4)
  
  print(paste0("Within Group Variance: ", v1))
  print(paste0("Between Group Variance: ", v2))
}
```
:::

```{r}
Extract_Variances(var_df)
```


# Logistic Hierarchies

::::: {.panel-tabset}

## Stan

```{r}
airbnb_for_stan <- airbnb_df |>
  mutate(room_bin = ifelse(room_type == "Entire home/apt", 1, 0)) |>
  group_by(ward) |>
  slice_sample(prop = 0.2) |>
  ungroup()

start_time <- Sys.time()

logistic_hier_model <- rstanarm::stan_glmer(
  room_bin ~ number_of_reviews + availability_365 + (1 | ward),
  data = airbnb_for_stan, family = binomial,
  chains = 3, iter = 4000*2, refresh = 0, seed = 320)

end_time <- Sys.time()
print(round(end_time- start_time))
```

## Diagnostics

```{r}
#| message: false
#| warning: false
model_diagnostics(logistic_hier_model)
```

## Classification

```{r}
set.seed(320)
class_results <- bayesrules::classification_summary(
  model = logistic_hier_model,
  data = airbnb_for_stan,
  cutoff = 0.55
)
```

```{r}
class_results$confusion_matrix
```

```{r}
class_results$accuracy_rates |> round(digits = 4)
```

:::::


# Poisson Hierarchies

::::: {.panel-tabset}

## Stan

```{r}
start_time <- Sys.time()

neg_bin_hier_model <- rstanarm::stan_glmer(
  price ~ number_of_reviews + availability_365 + room_type + 
    (1 | ward),
  data = airbnb_for_stan, family = neg_binomial_2,
  chains = 3, iter = 4000*2, refresh = 0, seed = 320)

end_time <- Sys.time()
print(round(end_time- start_time))
```

## Diagnostics

```{r}
#| message: false
#| warning: false
model_diagnostics(neg_bin_hier_model)
```

## MAE

```{r}
set.seed(320)
bayesrules::prediction_summary(neg_bin_hier_model, data = airbnb_df) |>
  mutate_if(is.numeric, round, digits = 4)
```

## PPC

```{r}
#| echo: false
#| eval: true
bayesplot::pp_check(neg_bin_hier_model) +
  labs(title = "Negative Binomial Model", x = "price") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")
```

```{r}
#| echo: true
#| eval: false
bayesplot::pp_check(neg_bin_hier_model) +
  labs(title = "Negative Binomial Model", x = "price") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")
```

:::::

# Predictions

::::: {.panel-tabset}

## Viz

```{r}
#| message: false
#| warning: false
#| echo: false
#| eval: true
set.seed(320)
ward_preds <- rstanarm::posterior_predict(
  neg_bin_hier_model, 
  newdata = data.frame(number_of_reviews = 100,
                       availability_365 = 200,
                       room_type = "Entire home/apt",
                       ward = c("A", "B", "C", "D", "E", "F")))

bayesplot::mcmc_areas(ward_preds, prob = 0.8) +
  labs(title = "Posterior Distributions for Airbnb Prices",
       subtitle = "Entire House with 100 reviews and 200 days/year availability",
       caption = "SML 320",
       x = "price", y = "ward") +
  scale_y_discrete(labels = c("A", "B", "C", "D", "E", "F"))
```

## Code

```{r}
#| message: false
#| warning: false
#| echo: true
#| eval: false
set.seed(320)
ward_preds <- rstanarm::posterior_predict(
  neg_bin_hier_model, 
  newdata = data.frame(number_of_reviews = 100,
                       availability_365 = 200,
                       room_type = "Entire home/apt",
                       ward = c("A", "B", "C", "D", "E", "F")))

bayesplot::mcmc_areas(ward_preds, prob = 0.8) +
  labs(title = "Posterior Distributions for Airbnb Prices",
       subtitle = "Entire House with 100 reviews and 200 days/year availability",
       caption = "SML 320",
       x = "price", y = "ward") +
  scale_y_discrete(labels = c("A", "B", "C", "D", "E", "F"))
```

:::::


# Deeper Hierarchies

```{r}
#| eval: false
deep_hier_model <- rstanarm::stan_glmer(
  price ~ number_of_reviews + availability_365 + 
    (1 | room_type) + (1 | ward),
  data = airbnb_df, family = gaussian,
  chains = 4, iter = 5000*2, refresh = 0, seed = 320)
```

* **TODO**: actually run the code


# BNNS

Here, we briefly look at the `BLNN` package (Bayesian learning for neural networks).

* vignette: https://github.com/BLNNdevs/BLNN/blob/master/vignettes/Classification_Modeling.Rmd

## Architecture

* `ncov = 2`: 2 input variables
* `nout = 6`: 6 output variables (for the `ward`)
* `hlayer_size = 8`: size of hidden layer

```{r}
ClassNet<-BLNN_Build(ncov = 3, nout = 6, hlayer_size = 8,
                      actF = "tanh",
                      costF = "crossEntropy",
                      outF = "softmax",
                      hp.Err = 10, hp.W1 = .5, hp.W2 = .5,
                      hp.B1 = .5, hp.B2 = .5)
```

## Data Wrangling

```{r}
set.seed(320)
airbnb_for_bnn <- airbnb_df |>
  mutate(room_bin = ifelse(room_type == "Entire home/apt", 1, 0)) |>
  select(ward, number_of_reviews, availability_365, room_bin) |>
  group_by(ward) |>
  slice_sample(prop = 0.2) |>
  ungroup()
```

### Targets Matrix

```{r}
targ <- matrix(0, 
               nrow = nrow(airbnb_for_bnn), 
               ncol = 6)
lev <- as.numeric(as.factor(airbnb_for_bnn$ward))
for(i in 1:nrow(airbnb_for_bnn)){
  targ[i, lev[i]]<-1
}
colnames(targ) <- c("ward_A", "ward_B", "ward_C", "ward_D", "ward_E", "ward_F")
input_data <- airbnb_for_bnn |>
  select(number_of_reviews, availability_365, room_bin)

# rescale data
input_data <- scale(input_data)
```

Also consider rescaling numerical variables.

### Train Network

```{r}
#| message: false
#| warning: false
nnetBasesline <- nnet::nnet(input_data, 
                            targ, 
                            size = 3) #hidden layer size
nnetPredictions <- predict(nnetBasesline)
```

### Hamiltonian Monte Carlo

```{r}
#| message: false
#| warning: false
start_time <- Sys.time()

ClassHMC <- BLNN_Train(NET = ClassNet,
                          x = input_data,
                          y = targ,
                          iter = 5000,
                          chains = 3,
                          algorithm = "HMC",
                          display = 0, control = list(adapt_delta = 0.8,
                                                      Lambda = 0.005,
                                                      stepsize=5,
                                                      gamma=2)
                        )

end_time <- Sys.time()
print(round(end_time- start_time))
```

## Update Network

```{r}
#| message: false
#| warning: false
start_time <- Sys.time()

ClassHMC<-BLNN_Update(ClassNet, ClassHMC)

end_time <- Sys.time()
print(round(end_time- start_time))
```

## Gather Predictions

```{r}
HMCpred <- BLNN_Predict(ClassNet, input_data)
```

## Examine Overall Error

```{r}
HMCpredClass <- matrix(0, 
                       nrow = nrow(airbnb_for_bnn), 
                       ncol = 6)
lev <- as.numeric(as.factor(HMCpred))
for(i in 1:nrow(airbnb_for_bnn)){
  HMCpredClass[i, lev[i]]<-1
}
colnames(HMCpredClass) <- c("ward_A", "ward_B", "ward_C", "ward_D", "ward_E", "ward_F")
```

```{r}
targ_df <- data.frame(targ) |>
  mutate(class = case_when(
    ward_A == 1 ~ "ward_A",
    ward_B == 1 ~ "ward_B",
    ward_C == 1 ~ "ward_C",
    ward_D == 1 ~ "ward_D",
    ward_E == 1 ~ "ward_E",
    ward_F == 1 ~ "ward_F",
  ))

HMCpredClass_df <- data.frame(HMCpredClass) |>
  mutate(class = case_when(
    ward_A == 1 ~ "ward_A",
    ward_B == 1 ~ "ward_B",
    ward_C == 1 ~ "ward_C",
    ward_D == 1 ~ "ward_D",
    ward_E == 1 ~ "ward_E",
    ward_F == 1 ~ "ward_F",
  ))

table(targ_df$class, HMCpredClass_df$class)
```







# Footnotes

* 

::: {.callout-note collapse="true"}
## Session Info

```{r}
sessionInfo()
```
:::


:::: {.columns}

::: {.column width="45%"}
	
:::

::: {.column width="10%"}

:::

::: {.column width="45%"}

:::

::::


::::: {.panel-tabset}



:::::
